<?xml version="1.0" encoding="UTF-8"?>
<Export generator="Cache" version="25" zv="Cache for Windows (x86-64) 2014.2 (Build 315U)" ts="2014-09-01 23:02:11">
<Project name="MDG-DEV" LastModified="2014-08-28 14:01:23.794007">
  <Items>
    <ProjectItem name="Includes.INC" type="MAC"></ProjectItem>
    <ProjectItem name="MDG.Request" type="CLS"></ProjectItem>
    <ProjectItem name="WEB.Broker" type="CLS"></ProjectItem>
  </Items>
</Project>


<Class name="MDG.Request">
<Super>%Persistent</Super>
<TimeChanged>63431,59189.44765</TimeChanged>
<TimeCreated>63407,36185.325569</TimeCreated>

<Parameter name="Path">
<Default>C:/temp/</Default>
</Parameter>

<UDLText name="T">
<Content><![CDATA[
// в текущей области создаём брокера для работы с проектом	

]]></Content>
</UDLText>

<Method name="CreateBroker">
<ClassMethod>1</ClassMethod>
<FormalSpec>broker</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 s File=##class(%File).%New()
 s st=File.CreateDirectory("c:\temp"),st=File.%Save() 
 s ns = $namespace, $namespace="%SYS"
 set st=##class(Security.Applications).Get(broker,.CSP)
 if st '=1 {
  w !,"Создан брокер "_broker_" для области "_ns
  Set cspProperties("AutheEnabled") = 64
  Set cspProperties("NameSpace") = ns
  Set cspProperties("DispatchClass") = "WEB.Broker"
  Set cspProperties("IsNameSpaceDefault") = 0
  Set tSC = ##Class(Security.Applications).Create(broker,.cspProperties)
  If $$$ISERR(tSC) throw ##Class(%Exception.StatusException).CreateFromStatus(tSC)
 }
 s $namespace=ns
]]></Implementation>
</Method>

<Method name="GetNamespaces">
<Description>
Получение областей</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    #dim tSC As %Status = $$$OK
    #dim tNS As %String
    set str=""
    w "["
    //Get the list of namespaces
    Do List^%SYS.NAMESPACE(.tList)
    Set tNS="" For  {
        Set tNS=$Order(tList(tNS),1,tValue) If tNS="" {Quit}
        set str=str_""""_tNS_""","
    }
	  w $E(str,1,*-1)
    w "]"
    Quit tSC
]]></Implementation>
</Method>

<Method name="GetPath">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	//##dim tempDir=..#Path
	#dim Path=""
	$$$THROWONERROR(st,##class(%ZEN.Auxiliary.jsonProvider).%ConvertJSONToObject(%request.Content,,.obj,1))

	s Path=obj.TempDir_obj.NameSpace
	s ProxyObject=##class(%ZEN.proxyObject).%New()
	s ProxyObject.Path=Path
	s ProxyObject.Dir=obj.TempDir
	d ProxyObject.%ToJSON()
	s %response.Status="200 OK"
	s File=##class(%File).%New()
	d File.CreateDirectory(obj.TempDir)
	d File.CreateDirectory(Path)
	do ..WriteClassFiles(obj.NameSpace,Path)
	do ..WriteWebFiles(obj.NameSpace,Path)
	do ..ROUTINE(obj.NameSpace,Path)
	q $$$OK
]]></Implementation>
</Method>

<Method name="WriteWebFiles">
<ClassMethod>1</ClassMethod>
<FormalSpec>NS,Path</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	s Path=Path_"/Web"
	#dim st As %Status=$$$OK
	s defapp = $System.CSP.GetDefaultApp(NS)
	s ns = $namespace, $namespace="%SYS"
  	k csp s csp = ##class(Security.Applications).Get(defapp,.csp)
  	s $namespace=ns
  	s File=##class(%File).%New()
  	s st=File.CreateDirectory(Path)
  	s Path=Path_defapp
  	s st=File.CreateDirectory(Path)
  	s st=File.CopyDir($g(csp("Path")),Path,1)
  	Q st
]]></Implementation>
</Method>

<Method name="WriteClassFile">
<ClassMethod>1</ClassMethod>
<FormalSpec>NS,Class,text</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	s Path=..#Path_NS_"/Classes"
	s File=##class(%File).%New()		
	s List=$LISTFROMSTRING(Class,".")
	s tempPath=Path_"/"
    for i=1:1:$LL(List)-1
    {
		s tempPath=tempPath_$LIST(List,i)_"/"
	    d File.CreateDirectory(tempPath)
	}
	s file=##class(%Stream.FileBinary).%New()
	s file.Filename=tempPath_$LIST(List,$LL(List))_".cls"
	
	s st=file.Write($ZCONVERT(text,"O","UTF8"))
	s st=file.%Save()
	q $$$OK
]]></Implementation>
</Method>

<Method name="WriteClassFiles">
<ClassMethod>1</ClassMethod>
<FormalSpec>NS,Path</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	s Path=Path_"/Classes"
	#dim st As %Status=$$$OK
	set sn = $namespace
    set $namespace = NS
	s File=##class(%File).%New()
	d File.CreateDirectory(Path)
	s s=##class(%SQL.Statement).%New()
    s sql = "SELECT * FROM %Dictionary.ClassDefinition  where NOT id %STARTSWITH '%' and system <>4"
   	s st=s.%Prepare(sql)
   	s rs=s.%Execute()
    while rs.%Next() {
	    s tempPath=Path_"/"
    	s List=$LISTFROMSTRING(rs.%Get("ID"),".")
    	for i=1:1:$LL(List)-1
    	{
	    	s tempPath=tempPath_$LIST(List,i)_"/"
	    	d File.CreateDirectory(tempPath)
	    }
	    s tSC=##class(%Compiler.UDL.TextServices).GetTextAsStream(NS,rs.%Get("ID"),.tStream)
	    s file=##class(%Stream.FileBinary).%New()
		s file.Filename=tempPath_$LIST(List,$LL(List))_".cls"
		s st=file.Write($ZCONVERT(tStream.Read(tStream.Size),"O","UTF8"))
		s st=file.%Save()
		k file
	}
	s $namespace=sn
	q st
]]></Implementation>
</Method>

<Method name="GetClass">
<Description>
Method returns the class text </Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	$$$THROWONERROR(st,##class(%ZEN.Auxiliary.jsonProvider).%ConvertJSONToObject(%request.Content,,.obj,1))
    #dim tSC As %Status = $$$OK
    #dim e As %Exception.AbstractException
    set temp=##class(%ZEN.proxyObject).%New()
   
    #dim tStream As %Stream.Character
    Try {
        Set tSC=##class(%Compiler.UDL.TextServices).GetTextAsStream(obj.NameSpace,obj.ClassName,.tStream)
        If $$$ISERR(tSC) Quit
       // Do tStream.OutputToDevice()
        //w $REPLACE($REPLACE(str,$C(10),"//n"),$C(13),"//r")
        s temp.SourceText=tStream.Read(tStream.Size)
        s temp.NameSpace=obj.NameSpace
        s temp.ClassName=obj.ClassName
        do temp.%ToJSON()
    } Catch (e) {
        Set tSC=e.AsStatus()
    } 
    Quit tSC
]]></Implementation>
</Method>

<Method name="GetClassList">
<Description>
 Список классов</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 $$$THROWONERROR(st,##class(%ZEN.Auxiliary.jsonProvider).%ConvertJSONToObject(%request.Content,,.obj,1))
   

    set sn = $namespace
    set $namespace = obj.NameSpace
    set s=##class(%SQL.Statement).%New()
    s sql = "SELECT * FROM %Dictionary.ClassDefinition  where NOT id %STARTSWITH '%' and system <>4"
   set st=s.%Prepare(sql)
   set str = ""
   set rs=s.%Execute()
  w "["
    while rs.%Next() {
          set str = str_ "{""Name"":"""_rs.%Get("ID")_"""},"
}
 w $E(str,1,*-1)
 w "]"
  set $namespace = sn
    q $$$OK
]]></Implementation>
</Method>

<Method name="UpdateClass">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	
    /*
    data: { namespace: "MDG-DEV",
          text: "Class Example.Studio Extends (%Persistent,%Populate)'+'\r\n{'+'\r\n//hgjgjgjgh'+'\r\n}",
          nameClass: "Example.Studio"
          }
    */
    $$$THROWONERROR(st,##class(%ZEN.Auxiliary.jsonProvider).%ConvertJSONToObject(%request.Content,,.obj,1))
    s sn=$namespace
    s $namespace= obj.namespace

    set st=##class(%Dictionary.ClassDefinition).%ExistsId(obj.nameClass)
    if ('st){
	    set nc = ##class(%Dictionary.ClassDefinition).%New(obj.nameClass)
	    set nc.Super = ""
    	set nc.Abstract = ""
	    set st = nc.%Save()
	    do ..WriteClassFiles(obj.namespace,..#Path)
	    }
    set stream=##class(%Stream.GlobalCharacter).%New()
    Do stream.Write($ZCONVERT(obj.text,"I","UTF8"))
    s st= ##class(%Compiler.UDL.TextServices).SetTextFromStream(obj.namespace, obj.nameClass, stream)
    w st
    //zw stream
    s $namespace=sn
    q $$$OK
]]></Implementation>
</Method>

<Method name="CreateClass">
<Description>
Cоздание класса</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    
    /*
    data: { namespace: "MDG-DEV",
          nameClass: "Example.Studio",
          Super: "%Persistent,%Populate",
          Abstract: "0",
          Description: "This is TestClass"
          }
    */
    $$$THROWONERROR(st,##class(%ZEN.Auxiliary.jsonProvider).%ConvertJSONToObject(%request.Content,,.obj,1))
    
    set sn = $namespace
    set $namespace = obj.namespace
    set o = ##class(%Dictionary.ClassDefinition).%New(obj.nameClass)
    //Super - ÑÐ¸Ð¿ ÐºÐ»Ð°ÑÑÐ°, ÑÐ¾ ÑÑÐ¾ Ð¸Ð´ÐµÑ Ð¿Ð¾ÑÐ»Ðµ Extends (%Populate,%Persistent, Ð´Ñ.ÐºÐ»Ð°ÑÑÑ)
    set o.Super = obj.Super
    //ÐÐ±ÑÑÑÐ°ÐºÑÐ½ÑÐ¹ Ð¸Ð»Ð¸ Ð½ÐµÑ (0 Ð¸Ð»Ð¸ 1)
    set o.Abstract = obj.Abstract
    //ÐÐ¿Ð¸ÑÐ°Ð½Ð¸Ðµ
    set o.Description = obj.Description
    set status = o.%Save()
    s tSC=##class(%Compiler.UDL.TextServices).GetTextAsStream(obj.namespace,obj.nameClass,.tStream)
	s file=##class(%Stream.FileBinary).%New()
	s Dir=##class(%File).%New()
	s Path=..#Path_obj.namespace_"/Classes"
	s tempPath=Path_"/"
    s List=$LISTFROMSTRING(obj.nameClass,".")
    for i=1:1:$LL(List)-1
    {
	    s tempPath=tempPath_$LIST(List,i)_"/"
	    d Dir.CreateDirectory(tempPath)
	}
	s file.Filename=tempPath_$LIST(List,$LL(List))_".cls"
	s st=file.Write($ZCONVERT(tStream.Read(tStream.Size),"O","UTF8"))
	s st=file.%Save()
	k file 
    set $namespace = sn
    q $$$OK
]]></Implementation>
</Method>

<Method name="CompilationClass">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
      $$$THROWONERROR(st,##class(%ZEN.Auxiliary.jsonProvider).%ConvertJSONToObject(%request.Content,,.obj,1))
      set sn = $namespace
      set $namespace = obj.namespace
      set str = ""
      set status=$system.OBJ.Compile(obj.nameClass)
      If $$$ISERR(status) 
        {  
	       w "[{""""ErrorText"":"  do $System.Status.DisplayError(status) w """}]"
	         } 
      set $namespace = sn
      q $$$OK
]]></Implementation>
</Method>

<Method name="DeleteClass">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
       $$$THROWONERROR(st,##class(%ZEN.Auxiliary.jsonProvider).%ConvertJSONToObject(%request.Content,,.obj,1))
       zw obj
       set sn = $namespace
      set $namespace = obj.namespace
      do ##class(%Studio.ClassMgr).Delete(obj.nameClass)
      set $namespace = sn
      Q $$$OK
]]></Implementation>
</Method>

<Method name="CreateMethod">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	
    	/*
	data: { namespace: "MDG-DEV",
          nameClass: "Example.Studio",
          ClassMethod: "1",
          nameMethod: "AtomIO",
          ReturnType: "%Status",
          Private: "0",
          Final: "1"
          }
          */
    $$$THROWONERROR(st,##class(%ZEN.Auxiliary.jsonProvider).%ConvertJSONToObject(%request.Content,,.obj,1))
    set sn = $namespace
      set $namespace = obj.namespace
        set method=##class(%Dictionary.MethodDefinition).%New(obj.nameClass)
        set method.ClassMethod=obj.ClassMethod
        set method.Name=obj.nameMethod
        set method.ReturnType = obj.ReturnType
        set method.Private = obj.Private
        set method.Final = obj.Final
        set status=method.%Save()   
        set $namespace = sn
    q $$$OK
]]></Implementation>
</Method>

<Method name="CreateProperty">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
      
      /*
      data: { namespace: "MDG-DEV",
          nameClass: "Example.Studio",
          nameProperty: "test123",
          Type: "%String",
          Relationship: "0",
          Required: "1",
          Calculated: "0"
          }
          */
      $$$THROWONERROR(st,##class(%ZEN.Auxiliary.jsonProvider).%ConvertJSONToObject(%request.Content,,.obj,1))
      set sn = $namespace
      set $namespace = obj.namespace
      set property=##class(%Dictionary.PropertyDefinition).%New(obj.nameClass)
      set property.Name = obj.nameProperty
      //ÐÐ¿Ð¸ÑÐ°Ð½Ð¸Ðµ
      set property.Description = obj.Description
      //Ð¢Ð¸Ð¿ ÑÐ²Ð¾Ð¹ÑÑÐ²Ð° (Ð½-Ñ, %Text)
      set property.Type = obj.Type
      //do ##class(MDG.Request).GetParameters()
       // ÐÐ¾Ð»Ð»ÐµÐºÑÐ¸Ñ (array Ð¸Ð»Ð¸ list)
      set property.Collection = obj.Collection
      //Отношение
      set property.Relationship = obj.Relationship
      set property.Required = obj.Required
      set property.Calculated = obj.Calculated
      //Запись параметров
      for i=1:1:obj.Parameter.Size{
	      do property.Parameters.SetAt(obj.Parameter.GetAt(i).Data,obj.Parameter.GetAt(i).Name)
	      }
      set status=property.%Save()
      set $namespace = sn
      q $$$OK
]]></Implementation>
</Method>

<Method name="GetParameters">
<Description>
Получение параметров</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	$$$THROWONERROR(st,##class(%ZEN.Auxiliary.jsonProvider).%ConvertJSONToObject(%request.Content,,.obj,1))
	s qqq = "%"_obj.Parameters
        set s=##class(%Library.ResultSet).%New("%Dictionary.ParameterDefinitionQuery:Summary")
  do s.Execute(qqq)
  set str = ""
  w "["
  while s.Next()
 {      
	 set str = str_ "{""Name"":"""_s.Get("Name")_"""},"
	}
 w $E(str,1,*-1)
 w "]"
  q $$$OK
]]></Implementation>
</Method>

<Method name="ROUTINE">
<ClassMethod>1</ClassMethod>
<FormalSpec>namespace,Path</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[

	#dim st As %Status=$$$OK
  	s Path=Path_"/PROGRAMMS"
  	s File=##class(%File).%New()
	d File.CreateDirectory(Path)
  	s routine=##class(%ResultSet).%New("%Library.Routine:RoutineList")
  	s st=routine.Execute("",1,"INT",namespace)
 
  	while routine.Next() {
	  	s ns=$namespace
	  	s $namespace=namespace
		s temp=##class(%Routine).%OpenId(routine.Get("Name"))
		s $namespace=ns	
	  	s tempPath=Path_"/"
    	s List=$LISTFROMSTRING(routine.Get("Name"),".")
  
    	for i=1:1:$LL(List)-3
    	{
	    	s tempPath=tempPath_$LIST(List,i)_"/"
	    	d File.CreateDirectory(tempPath)
	    }
	    
	    s file=##class(%Stream.FileBinary).%New()
		s file.Filename=tempPath_$LIST(List,$LL(List)-2)_"."_$LIST(List,$LL(List)-1)_"."_$ZCVT($LIST(List,$LL(List)),"L")
		//s TMP=##class(%Stream.TmpCharacter).%New()
		//d TMP.CopyFrom(temp)
		//w TMP.Read(TMP.Size)
		//zw temp
		s st=file.CopyFrom(temp)	//Write($ZCONVERT(TMP.Read(TMP.Size),"O","UTF8"))
		//w temp.Read(100)
		s st=file.%Save()

		k file
	   	
	}
  	
	q st
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^MDG.RequestD</DataLocation>
<DefaultData>RequestDefaultData</DefaultData>
<IdLocation>^MDG.RequestD</IdLocation>
<IndexLocation>^MDG.RequestI</IndexLocation>
<StreamLocation>^MDG.RequestS</StreamLocation>
<Data name="RequestDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="WEB.Broker">
<Super>%CSP.REST</Super>
<TimeChanged>63431,55686.160825</TimeChanged>
<TimeCreated>63431,55629.810634</TimeCreated>

<XData name="UrlMap">
<Data><![CDATA[
<Routes>
 
    <Route Url="/namespaces" Method="POST" Call="MDG.Request:GetNamespaces" />
    <Route Url="/namespaces/classlist" Method="POST" Call="MDG.Request:GetClassList" />
    <Route Url="/namespaces/classname" Method="POST" Call="MDG.Request:GetClass" />
    <Route Url="/updateclass" Method="POST" Call="MDG.Request:UpdateClass" />
    <Route Url="/createclass" Method="POST" Call="MDG.Request:CreateClass" />
    <Route Url="/compilationclass" Method="POST" Call="MDG.Request:CompilationClass" />
    <Route Url="/deleteclass" Method="POST" Call="MDG.Request:DeleteClass" />
    <Route Url="/createmethod" Method="POST" Call="MDG.Request:CreateMethod" />
    <Route Url="/createproperty" Method="POST" Call="MDG.Request:CreateProperty" />
    <Route Url="/getparameter" Method="POST" Call="MDG.Request:GetParameters"/>
    <Route Url="/getpath" Method="POST" Call="MDG.Request:GetPath"/>
    
</Routes>
]]></Data>
</XData>
</Class>
</Export>
